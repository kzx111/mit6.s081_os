# Chapter5_Interrupts_and_device_drivers

​	驱动(driver):是位于os里的代码，来管理特定的设备。作用：**配置设备硬件**，**控制设备操作**，**处理中断**，**与进程交互**。驱动程序代码的编写比较复杂，因为驱动程序与设备是**并发执行**的。

​	当设备需要操作系统的注意时（例如完成了一个I/O操作），它通常会通过**中断**来通知操作系统。在xv6操作系统中，内核的中断处理代码会识别设备产生的中断，并调用相应的驱动程序的**中断处理函数**。

​	驱动程序通常分为两个部分，分别在不同的上下文中执行：运行在**进程的内核线程**中，通常由系统调用（如`read`或`write`）触发，上半部分的代码会请求设备执行某个操作。运行在**中断上下文**中，由设备的中断触发，下半部分的代码负责处理中断，确定哪个操作已经完成，并唤醒等待该操作的进程（如果有）。

##  Console input

用户进程通过`read` system call来从console中一行行读取输入

### **控制台驱动程序(console driver)（位于kernel/console.c）的作用**

- 控制台驱动程序负责管理用户通过键盘输入的字符，并将这些字符传递给用户进程（如 shell）。
- 它通过 **UART 硬件** 与键盘和显示器进行通信。UART 是一种常见的串行通信硬件，用于在计算机和外部设备（如终端或其他计算机）之间传输数据。
- 在 xv6 中，UART 硬件由 QEMU 模拟，用户的键盘输入通过 QEMU 的模拟 UART 传递给 xv6。

### **UART 硬件的工作原理**

- UART 硬件通过 **内存映射寄存器（memory-mapped registers）** 与软件交互。这些寄存器位于特定的物理地址，CPU 通过加载（load）和存储（store）指令与这些寄存器交互，而不是直接访问内存。
- 在 xv6 中，UART 的寄存器从地址 `0x10000000`（即 `UART0`）开始。每个寄存器的功能不同，例如：
  - **LSR（Line Status Register）**：包含状态位，指示是否有输入字符**等待读取**。
  - **RHR（Receive Holding Register）**：存储从 UART 接收到的字符。每次读取一个字符后，UART 会从其内部的 FIFO（先进先出队列）中删除该字符。并且当队列为空，清除"ready"位在LSR。
  - **THR（Transmit Holding Register）**：当软件向 THR 写入一个字节时，UART 会将该字节发送出去。
- UART 的接收和发送硬件是独立的，可以同时工作。

### **控制台驱动程序的初始化**

- 在 xv6 启动时，`main` 函数会调用 `consoleinit`（位于 `kernel/console.c:182`）来初始化 UART 硬件。
- 初始化过程包括配置 UART，使其在以下情况下生成中断：
  - **接收中断**：当 UART 接收到一个字节的输入时。
  - **发送完成中断**：当 UART 完成一个字节的输出时。

### **控制台输入的处理流程**

- 用户进程（如 shell）通过 `read` 系统调用从控制台读取输入。
- `read` 系统调用最终会调用 `consoleread`（位于 `kernel/console.c:80`），该函数负责等待缓存在con.buf里的输入,然后将输入复制到用户空间并返回用户进程，并处理用户输入的行。
- 如果用户还没有输入完整的一行，`consoleread` 会通过 `sleep` 函数使进程进入睡眠状态，直到有完整的输入行可用。

### **中断处理**

- 当用户按下一个键时，UART 硬件会生成一个中断，通知 CPU 有输入字符到达。
- RISC-V 的中断处理机制会调用 `devintr`（位于 `kernel/trap.c:177`），该函数通过检查 `scause` 寄存器确定中断来源。
- 如果中断来自 UART，`devintr` 会调用 `uartintr`（位于 `kernel/uart.c:180`）。

### **UART 中断处理函数（uartintr）**

- `uartintr` 从 UART 硬件读取等待的输入字符，并将它们传递给 `consoleintr`（位于 `kernel/console.c:136`）。
- `uartintr` 不会等待字符，因为未来的输入会触发新的中断。

### **控制台输入处理函数（consoleintr）**

- `consoleintr` 负责将输入的字符累积到 `cons.buf` 缓冲区中，直到接收到完整的一行（以换行符 `\n` 结尾）。
- 它还会处理特殊字符，例如：
  - **退格键（Backspace）**：删除前一个字符。
  - **Ctrl+U**：删除整行。
- 当接收到完整的一行时，`consoleintr` 会唤醒等待的 `consoleread` 进程。

### **唤醒并返回用户空间**

- 一旦 `consoleread` 被唤醒，它会检查 `cons.buf` 中是否有完整的输入行。
- 如果有，它会将输入行复制到用户空间，并通过系统调用机制返回到用户进程。

















​		用户在键盘上输入了一个字符l，这个l通过键盘被发送到UART，然后通过PLIC发送到CPU的一个核，这个核产生中断，跑到`devintr`，`devintr`发现是来自UART的，调用`uartintr`，调用`uartgetc()`通过`RHR`寄存器来获取这个字符，然后调用`consoleintr`，判断这个字符是否是特殊字符(backspace等)，如果不是则将这个字符通过`consputc(c)`echo回给user，然后将其存储在`cons.buf`中，当发现整行已经输入完成后(`c=='\n' || c ==C('D'))`)，唤醒`consoleread()`

##  Console output

### 1. **写系统调用的流程**

- 当一个进程对连接到控制台的文件描述符执行 **写系统调用** 时，该调用最终会到达 `uartputc` 函数（位于 `kernel/uart.c:87`）。
- `uartputc` 负责将字符写入 UART 的输出缓冲区，并启动 UART 的传输。

------

### 2. **输出缓冲区的作用**

- 驱动程序维护了一个输出缓冲区 `uart_tx_buf`，用于存储待发送的字符。
- 使用缓冲区的目的是 **解耦进程和设备的操作**：
  - 进程不需要等待 UART 硬件完成发送操作，而是将字符追加到缓冲区后立即返回。
  - 这种设计使得进程可以继续执行其他任务，而不必阻塞等待设备完成 I/O 操作。

------

### 3. **uartputc 的工作流程**

- `uartputc` 的主要任务是将字符追加到输出缓冲区 `uart_tx_buf` 中。
- 如果缓冲区未满，`uartputc` 会将字符添加到缓冲区，并调用 `uartstart` 启动 UART 的传输（如果 UART 当前没有在发送数据）。
- 如果缓冲区已满，`uartputc` 会等待，直到缓冲区有空间。

------

### 4. **UART 传输的启动**

- `uartstart` 函数负责从输出缓冲区中取出字符并发送到 UART 硬件。
- 当 UART 硬件完成一个字节的发送时，它会生成一个 **传输完成中断**。

------

### 5. **中断处理**

- 每次 UART 完成发送一个字节时，都会生成一个中断。
- 中断处理函数 `uartintr` 会调用 `uartstart`，检查 UART 是否真的完成了发送，并将下一个缓冲区的字符交给 UART 硬件发送。
- 这种机制确保了缓冲区中的所有字符都能被依次发送。

------

### 6. **多字节写入的处理**

- 如果一个进程写入多个字节到控制台，通常会发生以下情况：
  - 第一个字节由 `uartputc` 调用 `uartstart` 直接发送。
  - 剩余的字节会被缓冲，并通过 `uartintr` 的中断处理函数逐步发送。
- 这种设计使得进程可以快速返回，而不必等待所有字节都发送完成。

------

### 7. **设备活动与进程活动的解耦**

- 驱动程序通过 **缓冲区和中断机制** 实现了设备活动与进程活动的解耦：
  - **输入处理**：控制台驱动程序可以在没有进程等待读取输入时处理输入字符，后续的 `read` 调用会看到这些输入。
  - **输出处理**：进程可以发送输出字符而不必等待设备完成发送。
- 这种解耦设计提高了系统的性能，允许进程与设备 I/O 并发执行。

------

### 8. **I/O 并发的重要性**

- 这种解耦设计在以下情况下尤为重要：
  - **设备速度较慢**：例如 UART 的传输速度通常比 CPU 慢得多，如果没有缓冲区，进程会长时间阻塞。
  - **需要即时响应**：例如在回显用户输入的字符时，设备需要立即处理输入并输出，而进程可以继续执行其他任务。
- 这种设计思想被称为 **I/O 并发（I/O concurrency）**，是操作系统高效管理设备 I/O 的关键。





## Concurrency in drivers



1.  **并发访问的危险性**

- 在控制台驱动程序中，多个进程或硬件中断可能同时访问共享的数据结构（如输入缓冲区 `cons.buf`），这会导致 **竞争条件（race conditions）** 或 **死锁（deadlocks）**。
- 具体来说，存在以下三种并发危险：
  1. **多个进程同时调用 `consoleread`**：
     - 如果两个进程在不同的 CPU 上同时调用 `consoleread`，它们可能会同时修改共享的数据结构（如 `cons.buf`），导致数据不一致。
  2. **硬件中断与 `consoleread` 的并发执行**：
     - 当一个 CPU 正在执行 `consoleread` 时，UART 硬件可能会向该 CPU 发送一个中断，导致中断处理函数（如 `uartintr` 或 `consoleintr`）与 `consoleread` 同时访问共享数据结构。
  3. **硬件中断在其他 CPU 上触发**：
     - 当一个 CPU 正在执行 `consoleread` 时，UART 硬件可能会向另一个 CPU 发送中断，导致中断处理函数与 `consoleread` 并发执行。

------

### 2. **锁的作用**

- 为了保护共享数据结构，控制台驱动程序使用 **锁（lock）** 来确保同一时间只有一个线程（或中断处理函数）可以访问这些数据结构。
- 在 `consoleread` 和 `consoleintr` 中，调用 `acquire` 函数获取锁，调用 `release` 函数释放锁。
- 锁的使用避免了竞争条件和死锁，确保了数据的一致性。

------

### 3. **中断处理的并发问题**

- 中断处理函数的执行可能发生在任何进程的上下文中，甚至可能在没有进程运行时触发。
- 因此，中断处理函数不能假设它们运行在某个特定的进程上下文中，也不能直接访问当前进程的资源（如页表）。
- 例如，中断处理函数不能安全地调用 `copyout` 函数（用于将数据从内核复制到用户空间），因为 `copyout` 需要当前进程的页表，而中断处理函数可能运行在与当前进程无关的上下文中。

------

### 4. **中断处理函数的设计原则**

- 由于中断处理函数的执行上下文不确定，它们通常只执行少量的工作，例如：
  - 将输入数据复制到缓冲区。
  - 唤醒等待的进程（如 `consoleread`）。
- 大部分工作由 **上半部分代码（top-half code）** 完成，例如 `consoleread` 负责将数据从缓冲区复制到用户空间。

















## Timer interrupts

### 1. **定时器中断的作用**

- 定时器中断用于维护操作系统的时钟，并支持在计算密集型进程之间进行切换。
- 在 xv6 中，定时器中断会周期性地触发，导致操作系统调用 `yield` 函数（位于 `usertrap` 和 `kerneltrap` 中），从而切换到其他进程。

------

### 2. **定时器中断的来源**

- 定时器中断来自每个 RISC-V CPU 上的时钟硬件。
- xv6 会配置时钟硬件，使其周期性地向每个 CPU 发送中断。

------

### 3. **RISC-V 的机器模式（Machine Mode）**

- RISC-V 要求定时器中断必须在 **机器模式（Machine Mode）** 下处理，而不是在 **监管模式（Supervisor Mode）** 下。
- 机器模式的特点：
  - 不支持分页（paging）。
  - 使用一组独立的控制寄存器。
- 由于机器模式与监管模式差异较大，xv6 无法直接在机器模式下运行普通的内核代码。因此，xv6 对定时器中断的处理与普通的中断/陷阱机制完全分离。

------

### 4. **定时器中断的初始化**

- 在 xv6 启动时，`start.c` 中的代码（在 `main` 函数之前运行）会初始化定时器中断（位于 `kernel/start.c:62`）。
- 初始化的任务包括：
  1. **配置 CLINT 硬件**：
     - CLINT（Core-Local Interruptor）是 RISC-V 的一个硬件模块，用于生成本地核心的中断。
     - xv6 会配置 CLINT，使其在一定延迟后生成定时器中断。
  2. **设置临时存储区（scratch area）**：
     - 类似于陷阱帧（trapframe），临时存储区用于保存寄存器和 CLINT 寄存器的地址。
  3. **设置 `mtvec` 寄存器**：
     - `mtvec` 是机器模式下的陷阱向量基址寄存器，xv6 将其设置为 `timervec`（定时器中断处理函数的地址）。
  4. **启用定时器中断**。

------

### 5. **定时器中断的处理**

- 定时器中断可以在用户代码或内核代码执行的任何时刻发生，内核无法在关键操作期间禁用定时器中断。
- 因此，定时器中断处理函数必须确保不会干扰被中断的内核代码。
- xv6 采用的策略是：
  1. **触发软件中断**：
     - 定时器中断处理函数会要求 RISC-V 生成一个 **软件中断（software interrupt）**，然后立即返回。
  2. **通过普通陷阱机制处理软件中断**：
     - RISC-V 将软件中断通过普通陷阱机制传递给内核，内核可以禁用软件中断。
  3. **在 `devintr` 中处理软件中断**：
     - 软件中断的处理代码位于 `devintr` 函数中（位于 `kernel/trap.c:204`）。

------

### 6. **机器模式下的定时器中断处理函数（timervec）**

- 定时器中断处理函数 `timervec` 是用汇编编写的（位于 `kernel/kernelvec.S:93`）。
- 它的主要任务包括：
  1. **保存寄存器**：
     - 将一些寄存器保存到 `start` 函数准备的临时存储区中。
  2. **配置下一次定时器中断**：
     - 告诉 CLINT 何时生成下一个定时器中断。
  3. **触发软件中断**：
     - 要求 RISC-V 生成一个软件中断。
  4. **恢复寄存器并返回**：
     - 恢复之前保存的寄存器，然后返回。
- 由于 `timervec` 是用汇编编写的，因此没有 C 代码。



## real world

### 1. **中断的全局启用**

- xv6 允许在 **内核代码** 和 **用户程序** 执行期间发生 **设备中断** 和 **定时器中断**。
- **定时器中断** 会强制进行线程切换（通过调用 `yield`），即使当前正在执行内核代码。
- 这种设计使得内核线程也能公平地分时共享 CPU 资源，特别是在内核线程长时间进行计算而不返回用户空间时非常有用。
- 然而，这种设计也增加了内核代码的复杂性，因为内核代码必须时刻注意它可能会被定时器中断挂起，并在另一个 CPU 上恢复执行。

------

### 2. **设备驱动的复杂性**

- 支持典型计算机上的所有设备是一项非常复杂的工作，因为：
  - 设备种类繁多，每种设备可能有多种功能。
  - 设备与驱动程序之间的协议可能非常复杂，且文档可能不完善。
- 在许多操作系统中，设备驱动程序的代码量甚至超过了核心内核的代码量。

------

### 3. **UART 驱动的工作方式**

- xv6 的 UART 驱动程序通过读取 UART 控制寄存器来逐字节获取数据，这种模式称为 **程序控制 I/O（Programmed I/O）**。
- **程序控制 I/O** 的优点是简单，但在高数据速率下效率较低。
- 对于需要高速传输大量数据的设备（如磁盘和网络设备），通常使用 **直接内存访问（DMA）**：
  - DMA 设备硬件直接将数据写入 RAM 或从 RAM 读取数据。
  - DMA 驱动程序只需在 RAM 中准备好数据，然后通过写入控制寄存器通知设备处理数据。

------

### 4. **中断与轮询**

- **中断** 适用于设备需要不定期且不频繁地通知 CPU 的场景。
- 但中断的 CPU 开销较高，因此高速设备（如网络和磁盘控制器）通常采用以下技巧来减少中断：
  1. **批量中断**：为一批输入或输出请求生成一个中断。
  2. **轮询（Polling）**：驱动程序禁用中断，并定期检查设备是否需要处理。
     - 轮询适用于设备操作非常快的场景，但如果设备大部分时间空闲，则会浪费 CPU 时间。
     - 一些驱动程序会根据设备负载动态切换中断和轮询模式。

------

### 5. **UART 驱动的数据拷贝**

- xv6 的 UART 驱动程序将输入数据首先复制到内核缓冲区，然后再复制到用户空间。
- 这种设计在低数据速率下是合理的，但在高数据速率下，双重拷贝会显著降低性能。
- 一些操作系统能够直接在用户空间缓冲区和设备硬件之间传输数据，通常使用 DMA。

------

### 6. **设备的控制**

- 控制台设备在应用程序中表现为一个普通文件，应用程序通过 `read` 和 `write` 系统调用进行输入和输出。
- 如果应用程序需要控制设备的某些特性（例如启用/禁用控制台驱动程序的**行缓冲**），可以使用 `ioctl` 系统调用。

------

### 7. **实时系统的局限性**

- 某些应用场景要求系统必须在**有限时间内**响应（例如安全关键系统），xv6 并不适合这些场景：
  - **硬实时系统**：要求系统必须在最坏情况下也能满足响应时间要求。xv6 不适合硬实时系统，因为它的调度器过于简单，且某些内核代码路径会长时间禁用中断。
  - **软实时系统**：允许偶尔错过截止时间。xv6 也不适合软实时系统，因为它的调度器和中断处理机制无法满足实时性要求。

------

### 8. **总结**

- xv6 允许在内核和用户代码执行期间发生中断，支持公平的 CPU 时间分配，但也增加了内核代码的复杂性。
- 设备驱动的实现复杂且代码量大，通常需要处理多种设备和协议。
- xv6 的 UART 驱动程序使用程序控制 I/O，适合低数据速率场景，但在高数据速率下效率较低。
- 高速设备通常使用 DMA 和批量中断来减少 CPU 开销。
- xv6 不适合实时系统，因为它的调度器和中断处理机制无法满足实时性要求。



## exersice

1. Modify uart.c to not use interrupts at all. You may need to modify console.c as well.
2.  Add a driver for an Ethernet card
