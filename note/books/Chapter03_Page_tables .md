**xv6:麻省理工学院（MIT）为操作系统工程的课程开发的一个教学目的的操作系统**

**makefile:便于工程的编译链接与调试**



# Page tables 

# xv6book



* xv6 技巧：
  * mapping the same memory (a trampoline page) in several address spaces
  
    > "Trampoline" 是一种跳板机制，通常用于在用户态和内核态之间切换。Trampoline page 是一块特殊的内存区域，包含一些代码或数据，用于实现这种切换。
    >
    > 操作系统可以将 trampoline page 映射到所有进程的地址空间中，这样每个进程都可以通过访问自己的虚拟地址空间来使用这块内存。这种设计通常用于实现系统调用或上下文切换，因为所有进程共享相同的 trampoline 代码，避免了为每个进程单独分配内存。
  
  * guarding kernel and user stacks with an unmapped page.
  
    > 为了防止栈溢出（stack overflow）导致内存破坏，操作系统通常会在内核栈和用户栈的边界放置一个未映射的页（guard page）。如果栈增长到边界并试图访问未映射的页，CPU 会触发页错误（page fault），操作系统可以捕获这个错误并终止进程，从而防止栈溢出破坏其他内存区域。



---

 

## Paging hardware

![xv6 RISC-V address translation details ](..\pic\Snipaste_2025-03-07_16-07-16.png)

RISC-V address translation details

 **PTE_V** indicates whether the PTE is present: if it is not set, a reference to the page causes an exception (i.e. is not allowed).

**PTE_R** controls whether instructions are allowed to read to the page. PTE_W controls whether instructions are allowed to write to the page. 

 **PTE_X** controls whether the CPU may interpret the content of the page as instructions and execute them.

**PTE_U** controls whether instructions in user mode are allowed to access the page; if PTE_U is not set, the PTE can be used only in supervisor mode. 





 To tell the hardware to use a page table, the kernel must write the physical address of the root page-table page into the **`satp register` **. A CPU will translate all addresses generated by subsequent instructions using the page table pointed to by its own satp.

## Kernel address space(内核地址空间)

xv6会为每一个进程分配一个页表来描述每个进程的用户空间并且创建一个单独的页表来描述内核地址空间。memlayout.h 声明了内核地址的常量。

![](..\pic\Snipaste_2025-03-07_17-07-43.png)

 On the left, xv6’s **kernel address space**. RWX refer to PTE read, write, and execute permissions. On the right, the RISC-V **physical address space** that xv6 expects to see. how this layout maps kernel virtual addresses to physical ad dresses







The kernel gets at RAM and memory-mapped device registers using **“direct mapping;”** that is, mapping the resources at virtual addresses that are equal to the physical address.  However,There are a couple of kernel virtual addresses that aren’t direct-mapped : 

1. **The trampoline page**.  

   位于虚拟地址顶部，用户页表拥有这个相同的映射。第四章详细说明该页表的作用，不过我们可以看到有趣的页表案例：一个物理页表（包括trampoline代码）映射到内核的虚拟地址空间中，一次映射到虚拟地址空间顶部，另一次是直接映射到虚拟地址空间

2. **The kernel stack pages**.

   每个进程拥有自己的内核栈，内核栈被映射到高地址以便在这个高地址下可留下为映射的guard page

虽然内核使用它们的栈通过高地址映射，但是对于内核直接映射也是可行的。另一个设计就用直接映射并使用栈也是直接映射。不过，这种方式下，提供guard page带来一些问题：保护页需要取消某些虚拟地址的映射（即让这些地址不指向任何物理内存）但这些虚拟地址原本是指向物理内存的，取消映射后，这些物理内存将难以被其他部分使用（因为它们的虚拟地址已经被取消映射了）。













##  create an address space(建立一个地址空间)

### 好好阅读源码，提升编程能力

* **vm.c ** :操作地址空间和页表

  + ***structure***  *pagetable _t* : really a pointer to a RISC-V root page-table page

  +  **functions ** 

    + **walk**: finds the PTE for a virtual address

      ```cpp
      pte_t *
      walk(pagetable_t pagetable, uint64 va, int alloc)
      {
        if(va >= MAXVA)
          panic("walk");
      
        for(int level = 2; level > 0; level--) {
          pte_t *pte = &pagetable[PX(level, va)];
          if(*pte & PTE_V) {
            pagetable = (pagetable_t)PTE2PA(*pte);
          } else {
            if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
              return 0;
            memset(pagetable, 0, PGSIZE);
            *pte = PA2PTE(pagetable) | PTE_V;
          }
        }
        return &pagetable[PX(0, va)];
      }
      ```

      通过va这虚拟地址找到可以映射到物理地址的pagetable entry所在的pagetable的地址，并将其返回。

      这个是三级页表，所以返回的是第三级页表的地址

      参数 ： pagetable_t 就是指向给定了页表的起始地址的指针(我的理解是一级页表)， va 就是 虚拟地址，

      alloc就是是否可分配要求的页表，如 alloc =1 ， 创建任意一个要求的页表
    
      
    
    + **mappages**:Create PTEs for virtual addresses starting at va that refer to physical addresses starting at pa. (在页表中建立一段虚拟内存到一段物理内存的映射)
    
    ``` cpp
    int
    mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
    {
      uint64 a, last;
      pte_t *pte;
    
      a = PGROUNDDOWN(va);   //向下取整以页表为单位
      last = PGROUNDDOWN(va + size - 1);
      for(;;){
        if((pte = walk(pagetable, a, 1)) == 0)
          return -1;
        if(*pte & PTE_V)
          panic("remap");
        *pte = PA2PTE(pa) | perm | PTE_V;
        if(a == last)
          break;
        a += PGSIZE;
        pa += PGSIZE;
      }
      return 0;
    }
    ```
    
    已知虚拟页表va得到虚拟页号a 和下一页的虚拟页号
    
    通过 walk得到 va 所对应的pte ,将pte修改为指向pa 和存在位为1并且有着perm规则的pte
    
    然后 a指向下一个页，pay也是，重复这个过程找到a指向last
    
    +  Functions starting with **kvm** manipulate the kernel page table
    
      + **kvmake()**  create a direct-map page table for the kernel.
      
      + **kvinithart()**  
      
        首先设置了satp寄存器，所以这里实际上是内核告诉mmu来使用刚刚设置好的page table 
      
        `good question:`当这里 asm volatile("csrw satp, %0" : : "r" (x));这条指令执行之后，下一个指令的地址会发生什么？
      
        在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。所以这条指令的执行时刻是一个非常重要的时刻。因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。这里能正常工作的原因是值得注意的。因为前一条指令还是在物理内存中，而后一条指令已经在虚拟内存中了。比如，下一条指令地址是0x80001110就是一个虚拟内存地址。
      
        
      
        
      
        The RISC-V has an instruction **sfence.vma** that flushes the current CPU’s TLB. 
      
        
      
      + **kvmmap() **  为kernel页表创建从va到pa的映射关系，该函数只在booting时候使用，内部通过mappages()函数实现
      
    + functions starting with **uvm** manipulate a user page table
    
    +  other functions are used for both. **copyout and copyin** copy data to and from user virtual addresses provided as system call arguments;

---



## Physical memory allocator（kalloc.c ）

* **struct run**  Each free page’s list element

  * `kvminit` 第一步为最高及page direction分配物理page ,下一步将这一段内存初始化为0

    然后通过kvmmap函数，将每一个I/O设备映射到内核，可将物理地址映射到相同的虚拟地址
  
  * **kinit** initializes the free list to hold every page between the end of the kernel and PHYSTOP.

    * ```c
       freerange(end, (void*)PHYSTOP);
      ```
  
  * kinit calls **freerange** to add memory to the free list via per-page calls to kfree. 
  
  * ```c
    void
    freerange(void *pa_start, void *pa_end)
    {
      char *p;
      p = (char*)PGROUNDUP((uint64)pa_start);  //freerange  uses PGROUNDUP to ensure that it frees only aligned                                                    //physical addresses
      for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
        kfree(p);
    }
    ```
  
    * **`kfree`**    The allocator starts with no memory; these calls to kfree give it some to manage.
  
      *  通过填充垃圾数据（`0x01`）来捕获悬空引用问题，使错误更快暴露。
      *  将被释放的内存页添加到空闲列表，以便后续重用。

      ```c
      memset(pa, 1, PGSIZE);
      ```
  
      1 .用 `0x01` 填充内存，将内存标记为“垃圾数据”, 2. 这样可以在调试时更容易发现悬空引用问题，防止程序错误地访问已释放的内存。3. 这是一种常见的调试和开发技巧，尤其在操作系统和底层编程中非常有用。
  
    * **` kalloc`** 
      * 从空闲列表中分配内存页，供内核使用。
  










## process address space



​					![](..\pic\Snipaste_2025-03-08_15-19-38.png)



当一个进程需要更多的用户内存时，xv6首先会使用kalloc来分配物理地址。kalloc会在进程页表添加PTE，并指向新的物理页表。

栈是一个单独的页面，并显示了由`exec`创建的初始内容。包含命令行参数字符串以及指向这些字符串的指针数组位于栈的最顶部。紧接其下的是一些值，这些值使得程序可以从`main`函数开始执行，就像刚刚调用了`main(argc, argv)`函数一样。





## sbrk

该系统调用会缩小或增加内存为进程。调用了growproc函数,该函数有调用了uvmalloc或uvmdealloc。

## exec

`exec`是创建地址空间中用户部分的系统调用。其初始化地址空间的用户部分通过一个文件系统的文件。



具体实现：

1. namei（）打开二进制文件，检查elf头是否正确，然后通过proc_pagetable()创建页表page table ,并将程序段装入内存中。
2. `exec` 要分配以及初始化用户栈了 two page: the user guard stack and the user stack.
3. Commit to the user image. 释放旧的page table,并将新的page table 与该进程数据结构的数据相结合

## excersice

1. Parse RISC-V’s device tree to find the amount of physical memory the computer has. 
2.  Write a user program that grows its address space by one byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the PTE for the new memory contain? 
3. Modify xv6 to use super pages for the kernel. 
4.  Modify xv6 so that when a user program dereferences a null pointer, it will receive an ex ception. That is, modify xv6 so that virtual address 0 isn’t mapped for user programs. 
5. Unix implementations of exec traditionally include special handling for shell scripts. If the f ile to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog ’s first  line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6. 
6. Implement address space randomization for the kernel







# 	Q

1. 当一个进程请求一个虚拟内存地址时，CPU会查看SATP寄存器得到对应的最高一级page table，这级page table会使用虚拟内存地址中27bit index的最高9bit来完成索引，如果索引的结果为空，MMU会自动创建一个page table吗？

`不会的，MMU会告诉操作系统或者处理器，抱歉我不能翻译这个地址，最终这会变成一个page fault。如果一个地址不能被翻译，那就不翻译。就像你在运算时除以0一样，处理器会拒绝那样做。`

2. 我想知道我们是怎么计算page table的物理地址，是不是这样，我们从最高级的page table得到44bit的PPN，然后再加上虚拟地址中的12bit offset，就得到了完整的56bit page table物理地址？

   `我们不会加上虚拟地址中的offset，这里只是使用了12bit的0。所以我们用44bit的PPN，再加上12bit的0，这样就得到了下一级page directory的56bit物理地址。这里要求每个page directory都与物理page对齐（也就是page directory的起始地址就是某个page的起始地址，所以低12bit都为0）。`

3. mmu是如何实现虚拟内存和实际物理内存的切换的

4. 3级的page table是由操作系统实现的还是由硬件自己实现的？

   `这是由硬件实现的，所以3级 page table的查找都发生在硬件中。MMU是硬件的一部分而不是操作系统的一部分。在XV6中，有一个函数也实现了page table的查找，因为时不时的XV6也需要完成硬件的工作，所以XV6有这个叫做walk的函数，它在软件中实现了MMU硬件相同的功能。`

5. 之前提到，硬件会完成3级 page table的查找，那为什么我们要在XV6中有一个walk函数来完成同样的工作？

   `非常好的问题。这里有几个原因，首先XV6中的walk函数设置了最初的page table，它需要对3级page table进行编程所以它首先需要能模拟3级page table。另一个原因或许你们已经在syscall实验中遇到了，在XV6中，内核有它自己的page table，用户进程也有自己的page table，用户进程指向sys_info结构体的指针存在于用户空间的page table，但是内核需要将这个指针翻译成一个自己可以读写的物理地址。如果你查看copy_in，copy_out，你可以发现内核会通过用户进程的page table，将用户的虚拟地址翻译得到物理地址，这样内核可以读写相应的物理内存地址。这就是为什么在XV6中需要有walk函数的一些原因。`

6. 对于不同的进程会有不同的kernel stack吗？

   `答案是的。每一个用户进程都有一个对应的kernel stack`



















## x86和rics 5

RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。

xv6 编译完后，得到一个kernel.asm，为整个内核的汇编代码，













## stack

每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的：

1. Return address总是会出现在Stack Frame的第一位
2.  指向前一个Stack Frame的指针也会出现在栈中的固定位置





![](..\pic\stack.png)



stack frame，有两个重要的寄存器，一个是fp（它指向当前Stack Frame的顶部），一个是sp（它指向当前Stack Frame的顶部）Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epilogue。









# 日志

### 2025年 3月9号

今天我学的好累哦，不过还是有点收获的，例如，看了mit课后知道booting过程页表的初始化，

老师用gdb调试的方式给我们展现了kvminit()在内存中的形式，其中将第一个kenel页表创建，和利用kvmmap

将内核的IO设备直接映射到内核地址空间中。还有kvminithart()函数，其中关于w_satp()中的一个汇编指令将已经初始化好的页的起始地址放入satp寄存器中，这一刻非常关键，因为之前每个指令都是以物理地址所获取的，指令结束后就是一切都是以虚拟地址的形式，且sfence_vma()用来刷新页表。



其实今天大部分时间都是用来配置虚拟机网路环境和gdb的安装，虚拟机今天突然没有网了，结果发现是IP地址和虚拟机的默认路由的网络好不对，虚拟机IP地址就是一个局域网内的地址，默认网关就是虚拟机连接外网的一个通道，还是得自己配。







### 3月10日

今天搞的有点晚了呀，现在快10点了，赶紧回顾一下

把RISC-V Calling Convention and Stack Frames看完了，分析了RISCV和x86的区别，

感觉还是没有什么收获，

老师带我们分析了栈和struct，知道栈的分配需要两个寄存器并且需要汇编语言来控制。





反思：其实有很多东西没有必要细究，这样太浪费时间了，今天效率不太高。







### 3月13日

今天把page table2021款完成了，但是我感觉花的时间还蛮多的，

今天我发现原来github可以将同的分支融入一起，我之前都是每完成一个实验就上传，

但是这样就把每一个实验孤立了起来，最后也达不到一个完完整整的实验，这个等我实验都弄完了，一定要调整调整



过的真的好快，我发现自己还是有点问题，这个月都过半了



反思：

这里有的实验和以后要学的内容有关，所以，可以用**跳读**的方法来进行学习。



