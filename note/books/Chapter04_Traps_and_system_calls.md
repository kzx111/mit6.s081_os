# Traps and system calls

​		有三种情况可以让cpu停止指令的正常执行并转向处理事件特别的代码。分别是**系统调用，异常还有设备中断**。trap就是描述这三种情况。

​		通常，在陷阱发生时正在执行的任何代码稍后都需要恢复，不需要知道任何事情特殊的事情发生了。也就是说，我们经常希望陷阱是透明的；这对于设备中断尤其重要，中断的代码通常不会预料到这一点。通常的顺序是，陷阱迫使控制权转移到内核中；内核保存寄存器和其他状态，以便可以恢复执行；内核执行相应的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从陷阱中返回；原始代码从暂停处继续执行。

​		Xv6处理内核中的所有陷阱，陷阱不会被传递给用户代码。在内核中处理陷阱对于**系统调用**来说很自然。对于**中断**来说是有意义的，因为隔离要求只允许内核使用设备，而且内核是一种在多个进程之间共享设备的方便机制。对于**异常**也是有意义的，因为xv6通过杀死违规程序来响应用户空间的所有异常。

​		Xv6陷阱处理分为四个阶段**：RISC-V CPU采取的硬件操作、为内核C代码铺平道路的一些汇编指令、决定如何处理陷阱的C函数以及系统调用或设备驱动程序服务例程。**虽然三种陷阱类型之间的共性表明，内核可以用一个代码路径处理所有陷阱，但事实证明，为三种不同的情况编写单独的代码是方便的：来自用户空间的陷阱、来自内核空间的陷阱和定时器中断。处理陷阱的内核代码（汇编程序或C）通常称为处理程序（handle）；第一处理程序指令通常用汇编程序（而不是C）编写，有时也称为向量(vector)。

##  RISC-V trap machinery

​		RISC-V CPU 有一组控制寄存器，内核往该寄存器里面写去告诉CPU如何处理trap。内核往里面读为了发现一个已经出现的trap。有的寄存器非常重要：

* stvec : 内核将trap handle地址写入此处
* sepc : trap 发生时，RISC-V将PC保存此处。指令sret复制sepc到pc，内核可以写sepc去控制sret指令将会去哪。
* scause：RISC-V将一个值放在此处来描述trap的原因。
* sscratch:内核在陷阱发生时会在此处存储一个值，这个值在陷阱处理程序的最初阶段非常有用
* sstatue:   **SIE 位**  ：控制设备中断的启用或禁用。内核可以通过清零 SIE 推迟中断处理，确保关键代码的执行不被中断打断。**SPP 位**：指示陷阱的来源模式（用户模式或监管者模式），并控制 `sret` 指令的返回哪种模式。

​		上述寄存器与在**监管者模式**下处理的陷阱相关，这些寄存器在**用户模式**下无法读取或写入。对于在**机器模式**下处理的陷阱，存在一组类似的控制寄存器；xv6 仅在处理**定时器中断**的特殊情况下使用这些寄存器。在多核芯片中，每个 CPU 都有自己独立的一组寄存器，并且在任何给定时刻，可能有多个 CPU 同时处理陷阱。

​		RISC-V `硬件`在触发陷阱时的行为：

1. **设备中断的特殊处理**：如果陷阱是设备中断，并且 `sstatus` 寄存器中的 `SIE` 位（Supervisor Interrupt Enable）被清零（即中断被禁用），则硬件不会执行后续步骤。
2. **禁用中断**：硬件会通过清零 `sstatus` 寄存器中的 `SIE` 位来禁用中断。这是为了防止在处理当前陷阱时被其他中断打断。
3. **保存程序计数器（PC）**：硬件将当前的程序计数器（`pc`）值保存到 `sepc`（Supervisor Exception Program Counter）寄存器中。这是为了在陷阱处理完成后能够恢复执行。
4.  **保存当前模式**：硬件将当前的模式（用户模式或监管者模式）保存到 `sstatus` 寄存器的 `SPP`（Supervisor Previous Privilege）位中。这是为了在陷阱处理完成后能够返回到正确的模式。
5. **设置陷阱原因**：硬件将 `scause`（Supervisor Cause）寄存器设置为当前陷阱的原因（例如，系统调用、页错误、设备中断等）。
6.  **切换到监管者模式**：硬件将当前模式设置为监管者模式（Supervisor Mode），以便内核可以处理陷阱。
7.  **跳转到陷阱处理程序**：硬件将 `stvec`（Supervisor Trap Vector）寄存器的值复制到 `pc` 中。`stvec` 指向内核中陷阱处理程序的入口地址
8. **开始执行陷阱处理程序**：硬件从新的 `pc` 地址开始执行，即跳转到内核的陷阱处理程序。







### Q:硬件cpu未完成的任务：

1. CPU 不会自动切换到内核页表

2.  CPU 不会自动切换到内核栈

3. 除了 `pc`，CPU 不会自动保存其他寄存器（如通用寄存器）

   这些需要内核软件来完成。

### Q:为什么硬件只做最小的工作？

### 硬件只完成最必要的步骤，以便为操作系统提供最大的灵活性。例如，某些操作系统可能会在某些情况下省略页表切换，以提高陷阱处理的性能。通过减少硬件的固定操作，操作系统可以根据具体需求优化陷阱处理流程。

### Q:为什么不能随意省略以上的步骤？

- **安全性**：
  - 如果省略某些步骤（例如不切换 `pc`），可能会导致严重的安全问题。例如：
    - 如果硬件不切换 `pc`，用户模式的代码可能会在监管者模式下执行，从而破坏用户/内核的隔离性。
    - 用户代码可能会修改 `satp` 寄存器（指向页表），从而访问整个物理内存，导致系统崩溃或数据泄露。
- **正确性**：
  - 每个步骤都是为了确保陷阱处理的正确性和系统的稳定性。省略步骤可能会导致不可预测的行为。





## Traps from user space

xv6 根据陷阱是在内核中执行还是在用户代码中执行，采取不同的处理方式。以下是用户代码触发陷阱的处理流程；

#### 用户空间陷阱的触发

当用户程序执行系统调用（`ecall` 指令）、进行非法操作或设备中断时，可能会在用户空间触发陷阱。用户空间陷阱的高级处理路径如下：

1. **uservec**（`kernel/trampoline.S:16`）：陷阱处理的入口。
2. **usertrap**（`kernel/trap.c:37`）：确定陷阱原因并处理。
3. **usertrapret**（`kernel/trap.c:90`）：准备返回用户空间。
4. **userret**（`kernel/trampoline.S:88`）：最终返回到用户空间。







#### 设计约束

xv6 陷阱处理设计的一个主要约束是：**RISC-V 硬件在触发陷阱时不会切换页表**。这意味着：

- 陷阱处理程序的地址（`stvec` 指向的地址）必须在用户页表中有有效的映射，因为陷阱处理代码开始执行时，使用的仍然是用户页表。
- xv6 的陷阱处理代码需要切换到内核页表，因此内核页表也必须映射 `stvec` 指向的处理程序。



其实stvec就是trampoline.S的地址，即用户页表和内核页表都要有trampoline.S的映射。接下来会说明，主要还是看源码吧。







#### 解决方案：蹦床页面（Trampoline Page）

xv6 使用 **蹦床页面** 来满足这些要求：

- 蹦床页面包含 `uservec`，即 `stvec` 指向的陷阱处理代码。
- 蹦床页面在**每个进程的页表**中映射到地址 `TRAMPOLINE`，位于虚拟地址空间的末尾，以避免与用户程序使用的内存冲突。
- 蹦床页面也在**内核页表**中映射到相同的地址 `TRAMPOLINE`。
- 由于蹦床页面在用户页表中映射并设置了 `PTE_U` 标志，陷阱可以在监管者模式下开始执行。
- 由于蹦床页面在内核地址空间中映射到相同的地址，陷阱处理程序在切换到内核页表后可以继续执行。

#### 用户陷阱处理程序：`uservec`

`uservec` 的代码位于 `trampoline.S`（`kernel/trampoline.S:16`）。当 `uservec` 开始时，所有 32 个寄存器都包含被中断的用户代码的值。这些值需要保存到内存中，以便在陷阱返回用户空间时恢复。保存到内存需要使用寄存器来保存地址，但此时没有可用的通用寄存器！

RISC-V 提供了 `sscratch` 寄存器来帮助解决这个问题：

- `uservec` 开头的 `csrrw` 指令交换 `a0` 和 `sscratch` 的内容。

- 现在，用户代码的 `a0` 被保存在 `sscratch` 中，`uservec` 可以使用 `a0` 寄存器，而 `a0` 包含内核之前放置在 

  `sscratch` 中的值。

#### 1. 保存用户寄存器

`uservec` 的下一个任务是保存 32 个用户寄存器。在内核进入用户空间之前，内核将 `sscratch` 设置为指向一个 **每进程陷阱帧（trapframe）** 结构，该结构中有空间保存 32 个用户寄存器（`kernel/proc.h:44`）。由于 `satp` 仍然指向用户页表，`uservec` 需要陷阱帧在用户地址空间中有映射。

在创建每个进程时，xv6 会为进程的陷阱帧分配一个页面，并将其映射到用户虚拟地址 `TRAPFRAME`（位于 `TRAMPOLINE` 下方）。进程的 `p->trapframe` 也指向陷阱帧，但其物理地址供内核通过内核页表使用。

#### 2. 切换到内核页表

在交换 `a0` 和 `sscratch` 后，`a0` 指向当前进程的陷阱帧。`uservec` 现在将所有用户寄存器保存到陷阱帧中，包括从 `sscratch` 读取的用户 `a0`。

陷阱帧包含当前进程的内核栈地址、当前 CPU 的 `hartid`、`usertrap` 函数的地址以及内核页表的地址。`uservec` 检索这些值，将 `satp` 切换到内核页表，并调用 `usertrap`。

#### 用户陷阱处理：`usertrap`

`usertrap` 的任务是确定陷阱的原因、处理它并返回（`kernel/trap.c:37`）。它首先更改 `stvec`，以便在内核中触发陷阱时由 `kernelvec` 处理，而不是 `uservec`。它保存 `sepc` 寄存器（保存的用户程序计数器），因为 `usertrap` 可能会调用 `yield` 切换到另一个进程的内核线程，而该进程可能会返回到用户空间，在此过程中修改 `sepc`。

如果陷阱是系统调用，`usertrap` 调用 `syscall` 处理；如果是设备中断，调用 `devintr`；否则是异常，内核会终止出错的进程。系统调用路径将保存的用户程序计数器加 4，因为 RISC-V 在系统调用时会将程序指针指向 `ecall` 指令，但用户代码需要从下一条指令恢复执行。

在返回之前，`usertrap` 检查进程是否已被终止或是否应让出 CPU（如果这是一个定时器中断）。

#### 返回用户空间：`usertrapret` 和 `userret`

返回用户空间的第一步是调用 `usertrapret`（`kernel/trap.c:90`）。该函数设置 RISC-V 控制寄存器，为将来从用户空间触发的陷阱做准备。这包括：

- 将 `stvec` 更改为指向 `uservec`。
- 准备 `uservec` 依赖的陷阱帧字段。
- 将 `sepc` 设置为之前保存的用户程序计数器。

最后，`usertrapret` 调用映射在用户和内核页表中的蹦床页面上的 `userret`，因为 `userret` 中的汇编代码将切换页表。

`usertrapret` 调用 `userret` 时，将 `TRAPFRAME` 传递给 `a0`，并将进程的用户页表指针传递给 `a1`（`kernel/trampoline.S:88`）。`userret` 将 `satp` 切换到进程的用户页表。用户页表映射了蹦床页面和 `TRAPFRAME`，但没有映射内核的其他内容。蹦床页面在用户和内核页表中映射到相同的虚拟地址，这使得 `uservec` 在切换 `satp` 后可以继续执行。

`userret` 将陷阱帧中保存的用户 `a0` 复制到 `sscratch`，为后续与 `TRAPFRAME` 的交换做准备。从此时起，`userret` 只能使用寄存器内容和陷阱帧的内容。接下来，`userret` 从陷阱帧中恢复保存的用户寄存器，最后交换 `a0` 和 `sscratch` 以恢复用户 `a0` 并保存 `TRAPFRAME` 以供下一次陷阱使用，然后执行 `sret` 返回到用户空间。



## code：calling system calls

​		第2章以 `initcode.S` 调用 `exec` 系统调用（`user/initcode.S:11`）结束。让我们看看用户调用是如何进入内核中的 `exec` 系统调用实现的。

​		`initcode.S` 将 `exec` 的参数放入寄存器 `a0` 和 `a1` 中，并将系统调用号放入寄存器 `a7` 中。系统调用号与 `syscalls` 数组中的条目匹配，`syscalls` 是一个函数指针表（`kernel/syscall.c:108`）。`ecall` 指令会陷入内核，并导致 `uservec`、`usertrap` 和 `syscall` 依次执行，正如我们前面所看到的那样。

`		syscall`（`kernel/syscall.c:133`）从 `trapframe` 中保存的 `a7` 寄存器中检索系统调用号，并使用它来索引 `syscalls` 数组。对于第一个系统调用，`a7` 包含 `SYS_exec`（`kernel/syscall.h:8`），这将导致调用系统调用实现函数 `sys_exec`。

​		当 `sys_exec` 返回时，`syscall` 将其返回值记录在 `p->trapframe->a0` 中。这将导致原始用户空间的 `exec()` 调用返回该值，因为 RISC-V 的 C 调用约定将返回值放在 `a0` 中。系统调用通常返回负数表示错误，返回零或正数表示成功。如果系统调用号无效，`syscall` 会打印错误并返回 `1`。



## system call argument 

​		内核中的系统调用实现需要找到用户代码传递的参数。由于用户代码调用系统调用包装函数，参数最初按照 RISC-V 的 C 调用约定存放在寄存器中。内核的陷阱代码将用户寄存器保存到当前进程的陷阱帧（trap frame）中，内核代码可以从中找到这些参数。内核函数 `argint`、`argaddr` 和 `argfd` 从陷阱帧中获取第 `n` 个系统调用参数，分别作为整数、指针或文件描述符。它们都调用 `argraw` 来检索保存的用户寄存器（`kernel/syscall.c:35`）。

一些系统调用会传递指针作为参数，内核必须使用这些指针来读取或写入用户内存。例如，`exec` 系统调用向内核传递一个指针数组，这些指针指向用户空间中的字符串参数。这些指针带来了两个挑战。首先，用户程序可能存在错误或恶意行为，可能会传递一个无效的指针，或者试图让内核访问内核内存而不是用户内存。其次，xv6 内核的页表映射与用户页表映射不同，因此内核不能使用普通指令来加载或存储用户提供的地址。

内核实现了安全地在用户提供的地址之间传输数据的函数。`fetchstr` 是一个例子（`kernel/syscall.c:25`）。文件系统调用（如 `exec`）使用 `fetchstr` 从用户空间检索字符串文件名参数。`fetchstr` 调用 `copyinstr` 来完成实际的工作。

`copyinstr`（`kernel/vm.c:398`）从用户页表 `pagetable` 中的虚拟地址 `srcva` 复制最多 `max` 字节到目标地址 `dst`。由于 `pagetable` 不是当前的页表，`copyinstr` 使用 `walkaddr`（调用 `walk`）在 `pagetable` 中查找 `srcva`，得到物理地址 `pa0`。内核将每个物理 RAM 地址映射到对应的内核虚拟地址，因此 `copyinstr` 可以直接从 `pa0` 复制字符串字节到 `dst`。`walkaddr`（`kernel/vm.c:104`）会检查用户提供的虚拟地址是否属于进程的用户地址空间，从而防止程序欺骗内核读取其他内存。类似的函数 `copyout` 将数据从内核复制到用户提供的地址。





## traps form kernel space

xv6 根据 CPU 是在执行用户代码还是内核代码，对陷阱寄存器进行了不同的配置。当内核在 CPU 上执行时，内核将 `stvec` 指向 `kernelvec` 处的汇编代码（`kernel/kernelvec.S:10`）。由于 xv6 已经在内核中运行，`kernelvec` 可以依赖 `satp` 设置为内核页表，并且栈指针指向一个有效的内核栈。`kernelvec` 将所有 32 个寄存器压入栈中，稍后会从中恢复它们，以便被中断的内核代码可以不受干扰地继续执行。

`kernelvec` 将寄存器保存在被中断的内核线程的栈上，这是合理的，因为寄存器值属于该线程。如果陷阱导致切换到另一个线程，这一点尤为重要——在这种情况下，陷阱实际上会从新线程的栈返回，而被中断线程的保存寄存器则安全地留在其栈上。

`kernelvec` 在保存寄存器后跳转到 `kerneltrap`（`kernel/trap.c:134`）。`kerneltrap` 准备处理两种类型的陷阱：设备中断和异常。它调用 `devintr`（`kernel/trap.c:177`）来检查并处理前者。如果陷阱不是设备中断，那么它一定是异常，而在 xv6 内核中发生的异常总是致命的错误；内核会调用 `panic` 并停止执行。

如果 `kerneltrap` 是由于定时器中断而被调用，并且正在运行的是进程的内核线程（而不是调度器线程），`kerneltrap` 会调用 `yield` 以让其他线程有机会运行。在某个时刻，其中一个线程会调用 `yield`，并让我们的线程及其 `kerneltrap` 再次恢复。第 7 章将解释 `yield` 中发生的情况。

当 `kerneltrap` 的工作完成后，它需要返回到被陷阱中断的代码。由于 `yield` 可能已经破坏了 `sepc` 和 `sstatus` 中的先前模式，`kerneltrap` 在开始时保存了它们。现在它恢复这些控制寄存器并返回到 `kernelvec`（`kernel/kernelvec.S:48`）。`kernelvec` 从栈中弹出保存的寄存器并执行 `sret`，这将 `sepc` 复制到 `pc` 并恢复被中断的内核代码。

值得思考的是，如果 `kerneltrap` 由于定时器中断而调用了 `yield`，陷阱返回是如何发生的。

当 CPU 从用户空间进入内核时，xv6 将该 CPU 的 `stvec` 设置为 `kernelvec`；你可以在 `usertrap`（`kernel/trap.c:29`）中看到这一点。在内核开始执行但 `stvec` 仍设置为 `uservec` 的时间窗口内，至关重要的是在此期间不发生设备中断。幸运的是，RISC-V 在开始处理陷阱时总是禁用中断，而 xv6 在设置 `stvec` 之前不会再次启用中断。



## page_fault exception

xv6 对异常的处理方式相当简单：如果异常发生在用户空间，内核会终止引发错误的进程；如果异常发生在内核中，内核会触发 panic（崩溃）。然而，现实中的操作系统通常会以更有趣的方式处理异常。

### 1. **写时复制（Copy-on-Write, COW）**

许多内核使用页错误（page fault）来实现写时复制（COW）的 `fork` 机制。以 xv6 的 `fork` 为例（第 3 章中描述），`fork` 会使子进程的初始内存内容与父进程在 `fork` 时的内存内容相同。xv6 通过 `uvmcopy`（`kernel/vm.c:301`）实现 `fork`，它会为子进程分配物理内存并复制父进程的内存内容。然而，如果父子进程能够共享父进程的物理内存，效率会更高。简单的共享实现会导致父子进程通过写入共享的栈和堆互相干扰。

通过合理使用页表权限和页错误，父子进程可以安全地共享物理内存。CPU 在以下情况下会触发页错误异常：

- 虚拟地址在页表中没有映射。
- 映射的 `PTE_V` 标志未设置。
- 映射的权限位（`PTE_R`、`PTE_W`、`PTE_X`、`PTE_U`）禁止尝试的操作。

RISC-V 区分三种页错误：

- 加载页错误（load page fault）：加载指令无法转换其虚拟地址。
- 存储页错误（store page fault）：存储指令无法转换其虚拟地址。
- 指令页错误（instruction page fault）：程序计数器中的地址无法转换。

`scause` 寄存器指示页错误的类型，`stval` 寄存器包含无法转换的地址。

COW `fork` 的基本计划是让父子进程最初共享所有物理页，但将它们映射为只读（清除 `PTE_W` 标志）。如果任一进程尝试写入某个页，RISC-V CPU 会触发页错误异常。内核的陷阱处理程序会分配一个新的物理页，并将触发错误的地址映射的物理页内容复制到新页中。内核会修改故障进程页表中的相关 PTE，使其指向新页并允许读写，然后从触发错误的指令处恢复执行。由于 PTE 现在允许写入，重新执行的指令将不会再次触发错误。

COW 需要额外的簿记机制来决定何时可以释放物理页，因为每个页可能被多个页表引用，具体取决于 `fork`、页错误、`exec` 和退出的历史。这种簿记机制允许一个重要优化：如果进程触发存储页错误且该物理页仅被该进程的页表引用，则无需复制。

COW 使 `fork` 更快，因为 `fork` 不需要复制内存。虽然部分内存可能在写入时需要复制，但大多数内存通常不需要复制。一个常见的例子是 `fork` 后接 `exec`：`fork` 后可能会写入少量页，但子进程的 `exec` 会释放从父进程继承的大部分内存。COW `fork` 消除了复制这些内存的需要，并且对应用程序是透明的，无需修改应用程序即可受益。

------

### 2. **惰性分配（Lazy Allocation）**

页表和页错误的结合还带来了其他有趣的可能性，例如惰性分配。惰性分配分为两部分：

1. 当应用程序通过调用 `sbrk` 请求更多内存时，内核记录大小的增加，但不分配物理内存，也不为新范围的虚拟地址创建 PTE。
2. 当访问这些新地址时触发页错误，内核会分配一个物理页并将其映射到页表中。

与 COW `fork` 类似，内核可以透明地实现惰性分配。由于应用程序通常请求的内存比实际需要的多，惰性分配可以减少内核的工作量。此外，如果应用程序请求大量内存，惰性分配可以将成本分摊到多个页错误中，而不是一次性分配和清零大量页。

------

### 3. **按需分页（Demand Paging）**

另一个利用页错误的特性是按需分页。在 xv6 的 `exec` 中，所有应用程序的文本和数据都会被立即加载到内存中。由于应用程序可能很大且从磁盘读取数据很慢，这种启动成本可能对用户来说很明显。为了提高响应速度，现代内核会为用户地址空间创建页表，但将页的 PTE 标记为无效。在页错误时，内核从磁盘读取页内容并将其映射到用户地址空间。与 COW `fork` 和惰性分配一样，内核可以透明地实现这一特性。

------

### 4. **磁盘分页（Paging to Disk）**

当计算机的内存不足时，操作系统可以实现磁盘分页。其思想是仅将一部分用户页存储在 RAM 中，其余部分存储在磁盘的分页区域中。内核将对应于分页区域（而非 RAM）的 PTE 标记为无效。如果应用程序尝试使用已被换出到磁盘的页，会触发页错误，内核陷阱处理程序会分配一个物理页，从磁盘读取页内容到 RAM，并修改相关 PTE 指向 RAM。

如果物理 RAM 不足，内核必须先将某个物理页换出或驱逐到磁盘的分页区域，并将引用该物理页的 PTE 标记为无效。由于驱逐操作成本高昂，分页在内存访问具有良好的局部性时表现最佳。

------

### 5. **其他特性**

其他结合分页和页错误的特性包括：

- **自动扩展栈**：当栈空间不足时，内核可以通过页错误动态扩展栈。
- **内存映射文件**：将文件直接映射到进程的地址空间，通过页错误按需加载文件内容。

这些技术使操作系统能够更高效地管理内存，并在资源有限的情况下提供更好的性能。

## real world

**蹦床（trampoline）和陷阱帧（trapframe）** 的设计可能看起来过于复杂，但这种复杂性是由 RISC-V 的设计目标驱动的。RISC-V 在触发陷阱时尽可能少地执行操作，以实现非常快速的陷阱处理，这在实践中非常重要。因此，内核陷阱处理程序的前几条指令实际上必须在用户环境中执行：使用用户页表和用户寄存器内容。陷阱处理程序最初并不知道有用的信息，例如正在运行的进程的身份或内核页表的地址。

RISC-V 提供了一些受保护的地方，允许内核在进入用户空间之前存储信息：

- **`sscratch` 寄存器**：用于临时存储信息。
- **用户页表中指向内核内存的页表项**：这些页表项没有设置 `PTE_U` 标志，因此用户程序无法访问。

xv6 的蹦床和陷阱帧利用了这些 RISC-V 特性。如果内核内存被映射到每个进程的用户页表中（使用适当的 PTE 权限标志），则可以消除对特殊蹦床页的需求。这还将消除从用户空间陷入内核时切换页表的需要，从而使内核中的系统调用实现能够直接解引用用户指针，因为当前进程的用户内存已经被映射。

许多操作系统使用这些思想来提高效率。然而，xv6 避免了这些设计，以减少因意外使用用户指针而导致内核安全漏洞的可能性，并减少确保用户和内核虚拟地址不重叠所需的复杂性。

------

### 生产级操作系统的特性

生产级操作系统实现了许多高级特性，例如：

1. **写时复制（Copy-on-Write, COW）fork**：在 `fork` 时不立即复制内存，而是在写入时复制。
2. **惰性分配（Lazy Allocation）**：在应用程序请求内存时不立即分配物理内存，而是在首次访问时分配。
3. **按需分页（Demand Paging）**：在程序启动时不立即加载所有数据，而是在访问时从磁盘加载。
4. **磁盘分页（Paging to Disk）**：当物理内存不足时，将部分内存页换出到磁盘。
5. **内存映射文件（Memory-mapped Files）**：将文件直接映射到进程的地址空间，通过页错误按需加载文件内容。

此外，生产级操作系统会尝试充分利用所有物理内存，无论是用于应用程序还是缓存（例如文件系统的缓冲区缓存，我们将在第 8.2 节中讨论）。相比之下，xv6 在这方面显得较为简单：它不会充分利用物理内存，而是当内存不足时，向运行中的应用程序返回错误或终止它，而不是换出其他应用程序的页。

------

### 总结

- **蹦床和陷阱帧** 的设计是为了在 RISC-V 的约束下实现高效的陷阱处理。
- **生产级操作系统** 实现了许多高级内存管理特性，以充分利用硬件资源并提高性能。
- **xv6** 的设计更简单，避免了复杂性和潜在的安全风险，但也牺牲了一些性能和功能。

## exersice

1. The functions copyin and copyinstr walk the user page table in software. Set up the kernel page table so that the kernel has the user program mapped, and copyin and copyinstr can use memcpy to copy system call arguments into kernel space, relying on the hardware to do the page table walk. 
2. Implement lazy memory allocation. 
3. Implement COW fork.  
4.  Is there a way to eliminate the special TRAPFRAME page mapping in every user address space? For example, could uservec be modified to simply push the 32 user registers onto the kernel stack, or store them in the proc structure? 
5. Could xv6 be modified to eliminate the special TRAMPOLINE page mapping?

