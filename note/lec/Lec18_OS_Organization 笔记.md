# Lec 18: OS Organization 笔记



## 18.1 Monolithic kernel

monolithic kernel通常拥有例如文件系统这样强大的抽象概念，这比提供一些简单的抽象有着巨大的优势:

* 这些高度抽象的接口通常是**可移植的**，你可以在各种各样的存储上实现文件和目录，你可以使用文件和目录而不用担心它们是运行在什么牌子的磁盘，什么类型的存储之上，或许是SSD，或许是HDD，或许是NFS，但是因为文件系统接口是高度抽象的，所以它们都拥有相同的接口。
* Linux/Unix提供地址空间的抽象而不是直接访问MMU硬件的权限。
* 这里的强大的抽象还可以帮助管理共享资源。
* 因为所有这些功能都在一个程序里面，所有的内核子系统，例如文件系统，内存分配，调度器，虚拟内存系统都是集成在一个巨大的程序中的一个部分，这意味着它们可以访问彼此的数据结构，进而使得**依赖多个子系统的工具**更容易实现。
* 内核的所有代码都以完整的硬件权限在运行。

**缺点**:

* 第一个原因是它们大且复杂。随着时间的推移，它们倾向于发展成拥有所有的功能。
* 因为它们是如此之大，它们会削弱一些复杂的抽象能力。
* 可扩展性（Extensibility）。

## 18.2 Micro kernel

微内核的**核心**就是实现了IPC（Inter-Process Communication）以及线程和任务的tiny kernel。

在内核中唯一需要做的是支持进程/任务/线程，以及支持IPC来作为消息的传递途径

此之外，内核不用做任何事情。内核中没有任何文件系统，没有任何设备驱动，没有网络协议栈，所有这些东西以普通用户进程在运行。

课堂上举了fs和磁盘驱动程序的例子，

当文本编辑器VI需要读取一个文件时，它需要与文件系统进行交互，所以它通过IPC会发送一条消息到文件系统进程。文件系统进程中包含了所有的文件系统代码，它知道文件，目录的信息。文件系统进程需要与磁盘交互，所以它会发送另一个IPC到磁盘驱动程序。磁盘驱动程序再与磁盘硬件进行交互，之后磁盘驱动会返回一个磁盘块给文件系统。之后文件系统再将VI请求的数据通过IPC返回给VI。

![](https://github.com/huihongxiao/MIT6.S081/blob/master/.gitbook/assets/image%20(44).png?raw=true)





## 18.3 Why micro kernel?

人们构建微内核的动机是什么？

* 更小的内核或许会更加的安全。
* 在特殊场景下，你需要证明一个操作系统是正确的，没有Bug，并且只做了它应该做的事情。
* 小内核的另一个优势是，少量代码的程序比巨大的程序更容易被优化。
* 小内核可能会运行的更快，你不用为很多用不上的功能付出代价。
* 使用小内核的另一个原因是，小内核或许自带了少得多的设计限制，进而使得应用程序的设计限制也更少。
* 有很多我们习惯了位于内核的功能和函数，现在都运行在用户空间。
* 用户空间代码通常会比内核更容易被修改，调整和替换，所以它更容易被定制化。
* 将操作系统放在用户空间，或许可以使得它更加的健壮。
* 你可以在微内核上模拟或者运行多个操作系统。





## 18.4 L4 micro kernel

* 首先，L4是微内核，它只有7个系统调用，虽然其中有一些稍微有点复杂，但是它还是只有7个系统调用。
* 其次，L4并不大，论文发表的时候，它只有13000行代码，这并不多。
* 第三，它只包含几个非常基础的抽象。
* 另一个L4知道的事情是IPC。



## 18.5 Improving IPC by Kernel Design

##### 传统管道实现

- 异步传输
  * 因为在发送消息时，内核将每条消息都拷贝到了内部的缓存中，之后当接收消息时，又从buffer中将消息拷贝到了目标线程。
- 需要内核缓冲区存放信息
- 两个用户进程间通信需要:4 个相同调用, 2 个 send, 2 个 recv
- * 使用send系统调用，传入你想将消息发送到的线程的ID，以及你想发送消息的指针。
  * 它会调用recv系统调用，这个系统调用会返回发送消息线程的ID，并将消息从内核拷贝到P2的内存中。
- 8 次用户空间与内核空间的切换
- recv 时需要 sleep 等待数据
- 用户进程切换时需要至少一次线程调度和上下文切换

​		每一次用户空间和内核空间之间的切换和context switching都很费时，因为每次切换，都需要切换Page Table，进而清空TLB，也就是虚拟内存的查找缓存，这些操作很费时。所以这是一种非常慢的实现方式，它包含了大量的用户空间和内核空间之间的切换、消息的拷贝、缓存的分配等等。



**L4 fast IPC**

* 同步传输: P1 调用 send 时会等待 P2 调用 recv, 当两个进程都进入内核后, 直接将消息从 P1 拷贝至 P2(相当于 P1 进入内核返回到 P2)
* 无缓冲(Unbuffered): IPC 过程无需将数据由用户空间拷贝至内核空间
* 零拷贝(Zero Copy): 当消息极小时, 可以直接在寄存器中传递, 无需拷贝
* Page Mapping: 对于极长消息, 可以在 IPC 中携带页面映射, 页面会再次映射到目标任务的地址空间
* RPC: 使用 call 系统调用, 结合 send 和 recv 系统调用: 发送消息的同时等待其它任务的请求消息



## 18.6 Run Linux on top of L4 micro kernel

仍然有个问题，即使IPC很快了，操作系统的剩余部分从哪里去获取？

简单的将一个现有的monolithic kernel运行在微内核之上，而不是重新实现一些新的东西

![image (65).png (1104×688)](https://raw.githubusercontent.com/huihongxiao/MIT6.S081/master/.gitbook/assets/image (65).png)

* L4 作为内核运行在底部, Linux 作为一个服务运行在用户空间(作为一个任务)
* 每一个 Linux 用户进程又作为一个独立的 L4 任务运行. Linux 进程执行系统调用时会转换为发送到 Linux 任务的 IPC 消息并返回.
* L4 只有一个内核线程运行 Linux 内核, 而非每个用户进程对应一个 L4 内核线程. 用户进程的内核线程由 Linux 内核线程实现.
* L4 控制用户进程的调度运行
  缺点: 缺乏和 Linux 一样复杂的线程调度机制