# Lab: networking

## 背景

​		在编写代码之前，您可能会发现复习xv6书中的“第5章：中断和设备驱动程序”很有帮助。

​		您将使用名为E1000的网络设备来处理网络通信。对于xv6（以及您编写的驱动程序），E1000看起来像是连接到真实以太网局域网（LAN）的真实硬件。事实上，您的驱动程序将与之通信的E1000是qemu提供的仿真，连接到也由qemu仿真的局域网。在这个模拟局域网上，xv6（“访客”）的IP地址为10.0.2.15。Qemu还安排运行Qemu的计算机出现在IP地址为10.0.2.2的局域网上。当xv6使用E1000向10.0.2.2发送数据包时，qemu会将数据包传递到运行qemu的（真实）计算机（“主机”）上的相应应用程序。



## your job

**1. 设备手册核心章节**

- **目标芯片**：QEMU 模拟的 **82540EM** 型号 E1000 以太网控制器。
- **必读章节**：
  - **第2章**：设备概述（快速浏览，了解架构）。
  - **第3章**：通用操作与寄存器描述（驱动交互基础）。
  - **第4.1节**：数据传输机制（不包含子章节）。
  - **第14章**：接收与发送队列管理（核心功能）。
  - **第13章**：寄存器参考（开发时需频繁查阅）。
- **其他章节**：高级功能（如 VLAN、TCP 分段卸载）可暂时忽略。

------

#### **2. 驱动框架与初始化**

- **DMA 机制**：
  - E1000 通过 **直接内存访问（DMA）** 从 RAM 读取待发送数据包，并将接收的数据包直接写入 RAM。
  - 提供的 `e1000_init()` 函数已配置 DMA 缓冲区。
- **环形描述符队列**（bursts of packets might arrive faster than the driver can process them）：
  - **接收环（RX Ring）**：数组 `rx_desc`，每个描述符指向一个 `mbuf` 缓冲区（用于存储接收的数据包）。
  - **发送环（TX Ring）**：数组 `tx_desc`，驱动将待发送数据包的 `mbuf` 指针填入此处。
  - 环形队列大小由 `RX_RING_SIZE` 和 `TX_RING_SIZE` 定义。
- **mbuf 管理**：
  - `e1000_init()` 使用 `mbufalloc()` 预分配缓冲区，E1000 直接将数据 DMA 到这些缓冲区。

------

#### **3. 发送数据包实现**

- **函数入口**：`e1000_transmit(struct mbuf *m)`

-  `struct tx_desc` describes the descriptor format. 

- **步骤**：

  1. **获取空闲 TX 描述符**：
     - 检查描述符的 `E1000_TXD_STAT_DD` 状态位。若为 1，表示该描述符已被硬件处理完毕，可重用。
  2. **填充描述符**：
     - 将待发送数据包的 `mbuf` 的物理地址写入描述符的缓冲区地址字段。
     - 设置数据包长度等控制信息。
  3. **更新尾指针（TDT）**：
     - 通过寄存器 `regs[E1000_TDT]` 递增尾指针，通知 E1000 有新数据待发送。
  4. **mbuf 释放**：
     - **仅当 E1000 完成发送（`E1000_TXD_STAT_DD` 置 1）后** 才能释放 `mbuf`，否则需延迟释放。

- **代码示例**：

  ```c
  int e1000_transmit(struct mbuf *m) {
      uint32_t idx = regs[E1000_TDT]; // 当前尾指针
      struct tx_desc *desc = &tx_ring[idx];
      
      if (!(desc->status & E1000_TXD_STAT_DD)) {
          return -1; // 描述符忙，无法发送
      }
      
      // 释放前一个 mbuf（如果存在）
      if (tx_mbufs[idx]) {
          mbuffree(tx_mbufs[idx]);
          tx_mbufs[idx] = NULL;
      }
      
      desc->addr = (uint64_t)m->head; // 设置 DMA 地址
      desc->length = m->len;
      desc->cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP; // 标记数据包结束
      tx_mbufs[idx] = m; // 记录 mbuf 以便后续释放
      
      regs[E1000_TDT] = (idx + 1) % TX_RING_SIZE; // 更新尾指针
      return 0;
  }
  ```

------

#### **4. 接收数据包实现**

- **函数入口**：`e1000_recv(void)`

- **步骤**：

  1. **扫描 RX 环**：
     - 从 `regs[E1000_RDT]`（接收尾指针）的下一个位置开始检查描述符。
     - 若描述符的 `E1000_RXD_STAT_DD` 位为 1，表示有数据包到达。
  2. **处理数据包**：
     - 将 `mbuf` 传递给网络栈：调用 `net_rx()` 函数。
     - **注意**：`net_rx()` 可能直接处理或接管 `mbuf`，需根据实现决定是否立即释放。
  3. **分配新缓冲区**：
     - 使用 `mbufalloc()` 分配新 `mbuf`，更新当前描述符的缓冲区地址。
  4. **更新尾指针（RDT）**：
     - 修改 `regs[E1000_RDT]` 以通知 E1000 已处理完毕。

- **代码示例**：

  ```c
  void e1000_recv(void) {
      uint32_t idx = (regs[E1000_RDT] + 1) % RX_RING_SIZE;
      
      while (rx_ring[idx].status & E1000_RXD_STAT_DD) {
          struct mbuf *m = rx_mbufs[idx];
          m->len = rx_ring[idx].length; // 更新数据包长度
          
          net_rx(m); // 传递给网络栈
          
          // 分配新 mbuf 并更新描述符
          rx_mbufs[idx] = mbufalloc(0);
          rx_ring[idx].addr = (uint64_t)rx_mbufs[idx]->head;
          rx_ring[idx].status = 0; // 清除状态位
          
          idx = (idx + 1) % RX_RING_SIZE;
      }
      regs[E1000_RDT] = (idx - 1) % RX_RING_SIZE; // 更新尾指针
  }
  ```

------

#### **5. 中断处理**

- **接收中断**：当 E1000 收到数据包时触发中断，需在驱动中调用 `e1000_recv()`。
- **发送中断**：数据包发送完成后可能触发中断，用于释放已发送的 `mbuf`（若未在 `e1000_transmit()` 中立即释放）。

------

#### **6. 测试流程**

1. **启动测试服务器**：

   ```bash
   make server # 在主机终端运行
   ```

2. **启动xv6并运行测试**：

   ```bash
   make qemu  # 在另一个终端运行
   nettests    # 在xv6中执行
   ```

3. **预期结果**：

   - **成功**：`nettests` 输出 `testing ping: OK`，主机终端显示来自 xv6 的 UDP 数据包。
   - **失败**：未完成驱动时，数据包无法发送，无响应。

4. **ARP 处理**：

   - 主机首先发送 **ARP 请求** 查询 xv6 的 MAC 地址。
   - `kernel/net.c` 中的网络栈会自动回复 **ARP 应答**（需驱动正常工作）。

------

#### **7. 调试提示**

- **寄存器操作**：通过 `regs` 数组访问控制寄存器，例如：
  - `regs[E1000_STATUS]` 读取设备状态。
  - `regs[E1000_RDTR]` 设置接收中断延迟。
- **描述符状态检查**：始终在操作描述符前验证 `DD` 状态位。
- **内存屏障**：在更新尾指针后，可能需要插入内存屏障指令（如 `__sync_synchronize()`）确保写入对设备可见。

------

通过实现上述逻辑，E1000 驱动将能正确处理数据包的发送与接收，解除对PLIC区域的依赖，支持大尺寸程序与高效网络通信。



## 提示

* 发送
* * 首先，通过读取E1000_TDT控制寄存器，向E1000询问它预期下一个数据包的TX环索引。
  * 然后检查环是否溢出。如果E1000_TXD_STAT_DD未在E1000_TDT索引的描述符中设置，则E1000尚未完成相应的先前传输请求，因此返回错误。
  * 否则，使用mbuffree（）释放从该描述符传输的最后一个mbuf（如果有的话）。
  * 然后填写描述符。m->head指向内存中数据包的内容，m->len是数据包的长度。设置必要的cmd标志（请参阅E1000手册中的第3.3节），并隐藏指向mbuf的指针，以便以后释放。
  * 最后，通过将E1000_TDT模TX_ring_SIZE加1来更新环位置。
  * 如果e1000_transmit（）成功地将mbuf添加到环中，则返回0。如果失败（例如，没有可用于传输mbuf的描述符），返回-1，以便调用者知道释放mbuf。
* 接受
* * 首先，通过获取E1000_RDT控制寄存器并加一个模RX_ring_SIZE，向E1000询问下一个等待接收到的数据包（如果有的话）所在的环索引。
  * 然后通过检查描述符状态部分中的E1000_RXD_STAT_DD位来检查新数据包是否可用。如果没有，停下来。
  * 否则，将mbuf的m->len更新为描述符中报告的长度。使用net_rx（）将mbuf传递到网络堆栈。
  * 然后使用mbufallc（）分配一个新的mbuf来替换刚才给net_rx（）的一个。将其数据指针（m->head）编程到描述符中。将描述符的状态位清除为零。
  * 最后，将E1000_RDT寄存器更新为最后处理的环描述符的索引。
  * e1000_init（）使用mbufs初始化RX环，您需要看看它是如何做到的，也许还需要借用代码。
  * 在某一时刻，曾经到达的数据包总数将超过环大小（16）；确保你的代码能够处理这个问题。



您需要锁来应对xv6可能从多个进程使用E1000，或者在中断到达时在内核线程中使用E1000的可能性。