# mmap

​		mmap和munmap系统调用允许UNIX程序对其地址空间进行详细控制。它们可用于在进程之间共享内存，将文件映射到进程地址空间，以及作为用户级页面错误方案的一部分，如讲座中讨论的垃圾收集算法。在本实验中，您将把mmap和munmap添加到xv6中，重点放在内存映射文件上。

```c
void *mmap(void *addr, size_t length, int prot, int flags,	int fd, off_t offset);
```

​		mmap可以通过多种方式调用，但本实验室只需要其与文件内存映射相关的功能的一个子集。您可以假设addr始终为零，这意味着内核应该决定映射文件的虚拟地址。mmap返回该地址，如果失败，则返回0xFFFFFFFFFFF。length是要映射的字节数；它可能与文件的长度不同。prot指示内存是否应该被映射为可读、可写和/或可执行；你可以假设prot是prot_READ或prot_WRITE，或者两者兼而有之。标志将是MAP_SHARED，这意味着对映射内存的修改应该写回文件，或者是MAP_PRIVATE，这意味著它们不应该写回。您不必在标志中实现任何其他位。fd是要映射的文件的打开文件描述符。您可以假设偏移量为零（这是文件中映射的起点）。

​		如果映射同一map_SHARED文件的进程不共享物理页面，这是可以的。

​		munmap（addr，length）应删除指定地址范围内的mmap映射。如果进程修改了内存并将其映射为MAP_SHARED，则应首先将修改写入文件。munmap调用可能只覆盖mmap-ed区域的一部分，但您可以假设它将在开始、结束或整个区域取消映射（但不能在区域中间打孔）。

​		提示：

* 首先，将_mmaptest添加到UPROGS中，并**添加mmap和munmap系统调用**，以便编译user/mmaptest.c。目前，只需从mmap和munmap返回错误。我们在kernel/fcntl.h中为您定义了PROT_READ等。运行mmaptest，它将在第一次mmap调用时失败。
* 懒洋洋地填写页表，以应对页面错误。也就是说，mmap不应该分配物理内存或读取文件。相反，在usertrap中（或由usertrap调用）的页面错误处理代码中这样做，就像在懒惰的页面分配实验室中一样。懒惰的原因是确保大文件的mmap很快，并且可以对大于物理内存的文件进行mmap。
* 跟踪mmap为每个进程映射了什么。定义与第15讲**中描述的VMA（虚拟内存区域）相对应的结构，记录mmap创建的虚拟内存范围的地址、长度、权限、文件等**。由于xv6内核中没有内存分配器，因此可以声明一个固定大小的VMA数组，并根据需要从该数组进行分配。16号就足够了。
* 实现mmap：在进程的地址空间中找到一个未使用的区域来映射文件，并将VMA添加到进程的映射区域表中。VMA应包含指向被映射文件的结构文件的指针；mmap应该增加文件的引用计数，这样当文件关闭时，结构就不会消失（提示：请参阅filedup）。运行mmaptest：第一次mmap应该成功，但第一次访问mmaped内存将导致页面错误并终止mmaptest。
* 添加代码以在mmap-ed区域中导致页面错误，从而分配一页物理内存，将4096字节的相关文件读取到该页面中，并将其映射到用户地址空间。使用readi读取文件，它接受一个偏移参数，在该参数处读取文件（但您必须锁定/解锁传递给readi的inode）。别忘了在页面上正确设置权限。运行mmaptest；它应该到达第一张地图。
* 实现munmap：找到地址范围的VMA并取消映射指定的页面（提示：使用uvmunmap）。如果munmap删除了前一个mmap的所有页面，它应该减少相应结构文件的引用计数。如果修改了未映射的页面，并且文件映射为MAP_SHARED，请将页面写回文件。看看filewrite寻找灵感。
* 实际上，您的实现只会写回程序实际修改的MAP_SHARED页面。RISC-V PTE中的脏位（D）表示是否已写入页面。但是，mmaptest不会检查非脏页是否被写回；因此，您可以在不查看D位的情况下写回页面。
* 修改exit以取消映射进程的映射区域，就像调用了munmap一样。运行mmaptest；mmap_test应该通过，但可能不会通过fork_test。
* 修改fork以确保子对象具有与父对象相同的映射区域。不要忘记增加VMA结构文件的引用计数。在子级的页面错误处理程序中，可以分配一个新的物理页面，而不是与父级共享页面。后者会更酷，但需要更多的实现工作。运行mmaptest；它应该通过mmaptest和forktest。



[xiaofan](https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#144-lab-10-mmap)这个版本的代码不够全，

* 一方面，他遇到一个关于kfree为什么会去释放地址为0的内存空间，是因为，我们这里和lazy allocation一样，会发生pagetable才会分配资源。问题就是在 父进程wait中，等到子进程释放资源后，并释放子进程，期间要释放子进程的页表，而子进程页表有的地方，pte_v为0,这里我们可能原本就没有资源，可能只是延迟读或写，所以我们判断到这里pte为0应该要continue，继续判断下一个，而作者却没有这样做，毕竟人无完人
* 还有，该作者fork的时候未给子进程分配vmas，这个我自己加上去的，当然，exit的时候没有给子进程释放vmas资源。
* 还有脏位的设置，本代码并未设置，虽然实验说了，可以不用，但是设置了，os更加全

虽然改代码，也可以通过test但是还是有许多问题。





[csdn大佬的](https://blog.csdn.net/LostUnravel/article/details/121437327)

* mmap的思想：在heap顶部10个page大小的虚拟空间中分配vnas，每次分配寻找最高未分配的虚拟地址来进行分配
* munmap的思想，寻找对应的vma，如果vma为shared，遍历vma所覆盖的page，若vma为共享页面则遍历vma所覆盖的page，遍历到的page为脏的数据页，就仅仅将脏页写回磁盘中。这里参考 `filewrite()` 函数, 一次写入文件的大小还受日志 block 的影响。而且，pgsize和数据块（block:1024B）不一致，且每一次写日志的最大数目有限，所以要依次写回磁盘。然后，就是解除页表的映射关系，并分析addr的位置（头部和中间），全部写还是局部写。
* exit：释放子进程的vma和munmap思想差不多。
* fork：将父进程的vma复制给子进程
* pagetable这个部分；寻找发生pagetable的vam，如果是store指令导致的pagetable且虚拟空间有相应的pte并且该vma是可写的，则将该pte设置脏位，并设置可写，如果不满足条件，这说明是读指令，或者写指令但vma不可写，或者可写但是虚拟空间无对应的pte，此时我们就需要分配一个物理页框，初始化0，将该文件读取pagesize块到刚刚分配的物理内存中，注意，这里其实vma的offset就是vma->addr开始的数据在文件的偏移量。若vma修改权限为可读，这修改flags，若写命令且修改vma可写则修改flags为可写且为脏，将页框映射到页表中。